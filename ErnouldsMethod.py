'''
This script reads in a file generated by EMEBSD and interpolates patterns via the data


'''
import sys
import os
import numpy as np
import matplotlib.pyplot as plt

import h5py

# Add the parent directory to the Python path
sys.path.append(os.path.abspath("/Users/crestiennedechaine/Scripts/pyHREBSD/"))

from scipy.interpolate import RectBivariateSpline





def read_EMEBSD(filename):
    """
    Reads an EMEBSD .h5 file generated via EMsoft
    Returns an array of x by x pixels of the pattern as a numpy array.

    Arguments:
    - filename: path to the .h5 file
    Returns:
    - data: numpy array of the EBSD patterns
    """
    with h5py.File(filename, 'r') as f:
        ebsd_patterns = f['EMData/EBSD/EBSDpatterns'] #where the EBSD patterns are stored
        data = ebsd_patterns[:]

    #convert the data to a numpy array
    data = np.array(data)
    #remove the first dimension if it is 1
    if data.ndim > 2 and data.shape[0] == 1:
        data = data[0]
    else:
        print("Data has more than one dimension, keeping the original shape.")
        
    return data

def coordtransform(
        ref_coords, #the coordinates of the target pattern (before application of the inverse deformation tensor)
        PC, #defined in pixels in EMsoft coordinates, ie orgin is in the center of the detector
        Fe, #the deformation tensor(s) - shape (3,3) or (N,3,3)
):
    ''' 
    Arguments: 
    
    #takes in the pixel coordinates in the detector frame, with the origin at the pattern center 
    Note the pattern center is defined as unites of pixels (needed to convert the 16 mm measurement to pixels)
    
    takes in the coordiates of all the deformed pattern pixels (ie the experimental image coordinates), should be in regular rows 
    Modified from previous work in HREBSD-OPT on July 30 2025

    Utilizes equation 8 from chapter 4 of the atex paper

    Returns:
    - If Fe is (3,3): returns (H, W, 3) transformed coordinates, with the origin of the image at the pattern center
    '''

   

    ref_coords = np.asarray(ref_coords) #shape (H,W,3)
    PC = np.asarray(PC)
    direction = np.array([0, 0, 1], dtype=float)

    # single Fe (3,3)
    if Fe.ndim == 2:
        Finv = np.linalg.inv(Fe)  # (3,3) transpose taken because of mesh grid convention
        # use einsum to compute Finv @ v for each v in (H,W,3)
        #Finv = Fe
        deformed = np.einsum('ij,hwj->hwi', Finv, ref_coords)   # (H,W,3)
        projection = np.einsum('hwi,i->hw', deformed, direction)  # (H,W)
        proj_safe = np.where(np.isclose(projection, 0), 1e-12, projection)
        x = (PC[2] / proj_safe)[..., None] * deformed            # (H,W,3)
        return x
    
def pattern_coords(PC, detector_shape): # (H, W, 3) coordinates of detector pixels in detector frame
    # Use integer pixel coordinates (0..W-1, 0..H-1) and make coords[...,0]=x, coords[...,1]=y
    W = detector_shape[1]
    H = detector_shape[0]

    X, Y = np.meshgrid(
        np.arange(W),  # x coordinates (width)
        np.arange(H),  # y coordinates (height)
        indexing='xy'
    )  # X,Y shape -> (H, W)

    pixel_coordinates = np.stack((X, Y), axis=-1)  # shape (H, W, 2)
    # add z channel and set to detector distance
    pixel_coordinates = np.concatenate((pixel_coordinates, np.full((H, W, 1), PC[2], dtype=float)), axis=-1)  # (H,W,3)

    # Translate so origin is at the pattern center (PCx, PCy)
    # coords[...,0] is x => subtract PC[0]; coords[...,1] is y => subtract PC[1]
    pixel_coordinates[..., 0] -= PC[0]  # x - PCx
    pixel_coordinates[..., 1] -= PC[1]  # y - PCy

    return pixel_coordinates


def determineF(e, w, small_angle_approx=False):
    '''Single sample version
    Arguments:
    - e: (9,) elastic strain tensor  
    - w: (3,) rotation angles in degrees 
    
    Returns:
    - Fe: (3, 3) deformation gradient in the sample frame'''

    
    # Convert to radians
    w_rad = np.deg2rad(w)  # Shape: (3,)
    w1, w2, w3 = w_rad

    if small_angle_approx:
        # Small angle approximation for rotation matrix
        Rotation = np.array([[0, -w3, w2],
                             [w3, 0, -w1],
                             [-w2, w1, 0]])
        Fe = (np.eye(3) + e.reshape(3, 3)) + Rotation
    else:
    
    # Get the global rotation matrix in the sample frame
        c1, c2, c3 = np.cos(w1), np.cos(w2), np.cos(w3)
        s1, s2, s3 = np.sin(w1), np.sin(w2), np.sin(w3)
        Rotation = np.array([[c2 * c3, ((s1 * s2 * c3) - c1 * s3), ((c1 * s2 * c3) + s1 * s3)],
                            [c2 * s3, ((s1 * s2 * s3) + c1 * c3), ((c1 * s2 * s3) - s1 * c3)],
                            [-1 * s2, s1 * c2, c1 * c2]])
    

        #check that the rotation matrix does not have any -0 values
        Rotation[np.isclose(Rotation, 0)] = 0.0
    

        e_matrix = e.reshape(3, 3)


        Fe = (np.eye(3) + e_matrix) @ Rotation  # is F in the sample frame 
 
    return Fe

def interpolate_pattern(deformed_coords, reference_pattern, PC):
    '''
    Interpolates the reference pattern using the deformed coordinates.

    Arguments:
    - deformed_coords: (H, W, 3) or (N, H, W, 3) coordinates of the deformed pattern pixels
    - reference_pattern: (H, W) the original reference pattern
    Returns:
    - interpolated_pattern: (H, W) if input is (H, W, 3) or (N, H, W) if input is (N, H, W, 3)
    '''

    #print the reference pattern shape
    #print('the shape of reference pattern:', reference_pattern.shape)

    # Generate reference grid
    y_ref = np.arange(2400) 
    x_ref = np.arange(2400)


    # CORRECT: passing 1D strictly increasing arrays
    spline = RectBivariateSpline(
        y_ref,  # y (rows)
        x_ref,  # x (cols)
        reference_pattern,
        kx=5, ky=5,
        )
        
    interpolated_pattern = spline(
        deformed_coords[:, :, 1].flatten(),   # y (rows / PCy)
        deformed_coords[:, :, 0].flatten(),   # x (cols / PCx)
        grid=False
    )

    # Reshape the interpolated pattern to match the original shape
    interpolated_pattern = interpolated_pattern.reshape(deformed_coords.shape[0], deformed_coords.shape[1])
        
    return interpolated_pattern
    
def generate_patterns(
        Fe, #the deformation tensor(s) - shape (3,3) or (N,3,3)
        PC_vals, #pattern center in pixels (in the detector frame) with 0,0 at center matching EMsoft
        ref_coords,
        reference_pattern_EMEBSD, #the original reference pattern
    ):
    '''
    This is the main function that generates the deformed patterns based on the deformation tensors and reference pattern
    Generates the deformed patterns based on the deformation tensors and reference pattern.
    
    Prior to this function need to run 3 functions:
     - read_EMEBSD to read in the source pattern
     - pattern_coords to generate the undeformed reference coordinates
     - determineF to get the deformation tensor(s)

    Arguments
    - Fe: (9,) 
    - PC_vals: (3,) pattern center in pixels (in the detector frame, per Enrould's method)
    - ref_coords: the undeformed reference coordinates of the pattern pixels (should be 1200 by 1200 pixels)
    - ref_pattern: the original reference pattern (2400 by 2400 pixels), generated via read_EMEBSD
    Returns:
    - deformed_patterns: (H, W) or (N, H, W) deformed patterns
    '''

    #the ref coords should already be genterated
    deformed_coords = coordtransform(ref_coords, PC_vals, Fe) #apply the deformation tensor to the pixel coordinates
    #the deformed coords are now in the detector frame with the origin at the pattern center

    # ---- Coordinate shift, the origin of the smaller pattern is set to upper left and then 600 is added to account for larger pattern
    deformed_coords[:, :, 0] += PC_vals[0]  # Shift x coordinates (add PC)
    deformed_coords[:, :, 1] += PC_vals[1]  # Shift y coordinates
    deformed_coords[:, :, 0] += 600  # Shift x coordinates back
    deformed_coords[:, :, 1] += 600  # Shift y coordinates back


    interpolated_pattern_EMEBSD = interpolate_pattern(deformed_coords, reference_pattern_EMEBSD, PC_vals)

    #visualize_interpolation(reference_pattern_EMEBSD, deformed_coords, interpolated_pattern_EMEBSD, PC=PC_vals)
    return interpolated_pattern_EMEBSD

def generate_patterns_verbose(
        Fe, #the deformation tensor(s) - shape (3,3) or (N,3,3)
        PC_vals, #pattern center in pixels (in the detector frame) with 0,0 at center matching EMsoft
        ref_coords,
        reference_pattern_EMEBSD, #the original reference pattern
    ):
    '''
    This is the main function that generates the deformed patterns based on the deformation tensors and reference pattern
    Generates the deformed patterns based on the deformation tensors and reference pattern.
    
    Prior to this function need to run 3 functions:
     - read_EMEBSD to read in the source pattern
     - pattern_coords to generate the undeformed reference coordinates
     - determineF to get the deformation tensor(s)

    Arguments
    - Fe: (9,) 
    - PC_vals: (3,) pattern center in pixels (in the detector frame, per Enrould's method)
    - ref_coords: the undeformed reference coordinates of the pattern pixels (should be 1200 by 1200 pixels)
    - ref_pattern: the original reference pattern (2400 by 2400 pixels), generated via read_EMEBSD
    Returns:
    - deformed_patterns: (H, W) or (N, H, W) deformed patterns
    '''

    #the ref coords should already be genterated
    deformed_coords = coordtransform(ref_coords, PC_vals, Fe) #apply the deformation tensor to the pixel coordinates
    #the deformed coords are now in the detector frame with the origin at the pattern center

    #find the max and min of the deformed coords in the x and y directions
    x_min = np.min(deformed_coords[:, :, 0])
    x_max = np.max(deformed_coords[:, :, 0])
    y_min = np.min(deformed_coords[:, :, 1])
    y_max = np.max(deformed_coords[:, :, 1])


    # ---- Coordinate shift, the origin of the smaller pattern is set to upper left and then 600 is added to account for larger pattern
    #deformed_coords[:, :, 0] += PC_vals[0]  # Shift x coordinates (add PC)
    #deformed_coords[:, :, 1] += PC_vals[1]  # Shift y coordinates
    #deformed_coords[:, :, 0] += 600  # Shift x coordinates back
    #deformed_coords[:, :, 1] += 600  # Shift y coordinates back


    #interpolated_pattern_EMEBSD = interpolate_pattern(deformed_coords, reference_pattern_EMEBSD, PC_vals)

    #visualize_interpolation(reference_pattern_EMEBSD, deformed_coords, interpolated_pattern_EMEBSD, PC=PC_vals)
    return x_max, x_min, y_max, y_min

def F2h(Fe: np.ndarray, PC: tuple | list | np.ndarray) -> np.ndarray:
    """Calculate the homography from a deformation gradient using the projection geometry (pattern center).

    Args:
        Fe (np.ndarray): The deformation gradient.
        PC (tuple | list | np.ndarray): The pattern center.

    Returns:
        np.ndarray: The homography matrix."""
    # Reshape the deformation gradient if necessary
    if Fe.ndim == 3:
        Fe = Fe[None, ...]
    elif Fe.ndim == 2:
        Fe = Fe[None, None, ...]

    # Extract the data from the inputs
    x01, x02, DD = PC
    F11, F12, F13, F21, F22, F23, F31, F32 = Fe[..., 0, 0], Fe[..., 0, 1], Fe[..., 0, 2], Fe[..., 1, 0], Fe[..., 1, 1], Fe[..., 1, 2], Fe[..., 2, 0], Fe[..., 2, 1]


    # Calculate the homography
    g0 = DD + F31 * x01 + F32 * x02

    g11 = DD * F11 - F31 * x01 - g0
    g22 = DD * F22 - F32 * x02 - g0
    g13 = DD * (((F11 - 1) * x01) + (F12 * x02) + (F13 * DD)) + (x01 * (DD - g0))
    g23 = DD * ((F21 * x01) + ((F22 - 1) * x02) + (F23 * DD)) + (x02 * (DD - g0))
    h11 = g11 / g0
    h12 = (DD * F12 - F32 * x01) / g0
    h13 = g13 / g0
    h21 = (DD * F21 - F31 * x02) / g0
    h22 = g22 / g0
    h23 = g23 / g0
    h31 = F31 / g0
    h32 = F32 / g0
    H = np.array([h11, h12, h13, h21, h22, h23, h31, h32])

    # Reshape the output if necessary, only if have batch of homographies
    if H.ndim == 3:
        H = np.squeeze(np.moveaxis(H, (0, 1, 2), (1, 2, 0)))
    if H.ndim == 2:
        H = np.squeeze(H.T)

    return H

# ...existing code...
def visualize_interpolation(reference_pattern, deformed_coords, interpolated_pattern, PC, e = None, w = None, F = None, h=None):
    """
    Visualize the interpolation process.

    Arguments:
    - reference_pattern: (H_ref, W_ref) the full reference pattern
    - deformed_coords: (H, W, 3) coordinates used for interpolation
    - interpolated_pattern: (H, W) pattern interpolated from reference
    - PC: optional tuple (PCx, PCy) pattern center for plotting reference coordinates
    - e: optional strain (1x9 or 3x3) to display
    - w: optional rotation (3,) in degrees to display
    - h: optional homography (8,) to display
    """
    H_ref, W_ref = reference_pattern.shape
    H_det, W_det = deformed_coords.shape[:2]

    # ---- Coordinate shift, the origin of the smaller pattern is set to upper left and then 600 is added to account for larger pattern
    deformed_coords[:, :, 0] += PC[0]  # Shift x coordinates (add PC)
    deformed_coords[:, :, 1] += PC[1]  # Shift y coordinates
    deformed_coords[:, :, 0] += 600  # Shift x coordinates back
    deformed_coords[:, :, 1] += 600  # Shift y coordinates back


    coords_x = deformed_coords[:, :, 0]
    coords_y = deformed_coords[:, :, 1]

    fig, axes = plt.subplots(1, 3, figsize=(18, 6))

    # Original reference pattern
    axes[0].imshow(reference_pattern, cmap='gray', origin='upper')
    axes[0].set_title('Source Pattern (2400x2400 pixels)')
    
    axes[0].plot(PC[0]+600, PC[1]+600, 'ro', label='Pattern Center')
    axes[0].legend()
    axes[0].yaxis.set_visible(False)
    axes[0].xaxis.set_visible(False)


    # Deformed coordinates overlay
    axes[1].imshow(reference_pattern, cmap='gray', origin='upper')
    axes[1].scatter(coords_x.flatten(), coords_y.flatten(),
                    s=0.5, c='red', alpha=0.5)
    axes[1].set_title('Source Pattern with Deformed Coordinates Overlay')
    axes[1].set_xlim(0, W_ref)
    axes[1].set_ylim(H_ref, 0)  # flip y to match image coordinates
    axes[1].yaxis.set_visible(False)
    axes[1].xaxis.set_visible(False)

    # Interpolated pattern
    im = axes[2].imshow(interpolated_pattern, cmap='gray', origin='upper')
    axes[2].set_title('Interpolated Pattern (1200 x 1200 pixels)')
    axes[2].yaxis.set_visible(False)
    axes[2].xaxis.set_visible(False)

    # --- Add nicely formatted info box (strain, rotation, homography) on the interpolated panel ---
    info_lines = []
    # Strain: accept 1x9 or 3x3
    if e is not None:
        e_arr = np.asarray(e)
        if e_arr.size == 9:
            e_mat = e_arr.reshape(3,3)
        elif e_arr.shape == (3,3):
            e_mat = e_arr
        else:
            e_mat = e_arr.reshape(-1)[:9].reshape(3,3)
        # format small table, prefer 3x3 table but keep compact
        info_lines.append("Strain (e):")
        info_lines.append(f" e11 {e_mat[0,0]: .5f}  e12 {e_mat[0,1]: .5f}  e13 {e_mat[0,2]: .5f}")
        info_lines.append(f" e21 {e_mat[1,0]: .5f}  e22 {e_mat[1,1]: .5f}  e23 {e_mat[1,2]: .5f}")
        info_lines.append(f" e31 {e_mat[2,0]: .5f}  e32 {e_mat[2,1]: .5f}  e33 {e_mat[2,2]: .5f}")

    # Rotation (degrees)
    if w is not None:
        w_arr = np.asarray(w).ravel()
        # ensure length 3
        if w_arr.size >= 3:
            info_lines.append("")
            info_lines.append("Rotation (deg):")
            info_lines.append(f" w1 {w_arr[0]: .2f}  w2 {w_arr[1]: .2f}  w3 {w_arr[2]: .2f}")
        else:
            info_lines.append("")
            info_lines.append("Rotation:")
            info_lines.append(" " + "  ".join([f"{val: .2f}" for val in w_arr]))
    # Deformation Gradient (F) (9 params) -> print in three rows of 3
    if F is not None:
        F_arr = np.asarray(F).ravel()
        info_lines.append("")
        info_lines.append("Deformation Gradient F (9):")
        # pad/truncate to 9
        F9 = np.zeros(9)
        F9[:min(F_arr.size,9)] = F_arr[:9]
        info_lines.append(" " + "  ".join([f"F{i+1} {F9[i]: .5e}" for i in range(3)]))
        info_lines.append(" " + "  ".join([f"F{i+4} {F9[i+3]: .5e}" for i in range(3)]))
        info_lines.append(" " + "  ".join([f"F{i+7} {F9[i+6]: .5e}" for i in range(3)]))

    # Homography (8 params) -> print in two rows of 4
    if h is not None:
        h_arr = np.asarray(h).ravel()
        info_lines.append("")
        info_lines.append("Homography h (8):")
        # pad/truncate to 8
        h8 = np.zeros(8)
        h8[:min(h_arr.size,8)] = h_arr[:8]
        info_lines.append(" " + "  ".join([f"h{i+1} {h8[i]: .5e}" for i in range(3)]))
        info_lines.append(" " + "  ".join([f"h{i+4} {h8[i+3]: .5e}" for i in range(3)]))
        info_lines.append(" " + "  ".join([f"h{i+7} {h8[i+6]: .5e}" for i in range(2)]))

    if info_lines:
        info_text = "\n".join(info_lines)
        # place inside axes[2] lower left with a light background box and monospace font for alignment
        axes[0].text(
            0.01, 0.01, info_text,
            transform=axes[0].transAxes,
            fontsize=9,
            va='bottom',
            ha='left',
            family='monospace',
            bbox=dict(facecolor='white', alpha=0.85, edgecolor='black', boxstyle='round,pad=0.4')
        )

    if e is not None and w is not None:
        fig.suptitle(f'Interpolated Pattern with Strain and Rotation', fontsize=16)
        plt.subplots_adjust(top=0.85)

    if h is not None and (e is None and w is None):
        fig.suptitle(f'Interpolated Pattern with Homography', fontsize=16)
        plt.subplots_adjust(top=0.85)


    plt.show()



if __name__ == "__main__":
        # ---- Inputs ----
    #IMPORTANT: The F plotted in deformed coords is the inverse of Fe, need to edit coordtransform function to plot Fe directly
    Ernould_PC = np.array([600, 600, 16*1000/20]) #the pattern center to be used for Ernould's method
    detector_shape = (1200,1200)
       # Define a sample strain and rotation
    e = np.array([0.0, 0.0, 0.0,
                  0.0, 0.5, 0.0,
                  0.0, 0.0, 0.0])  # Example strain tensor
    w = np.array([2.0, 2.0, 2.0])  # Example rotation angles in degrees

    EMEBSDfilename = '/Users/crestiennedechaine/Scripts/pyHREBSD/EBSDpattern_Al_July222025.h5'
    
    # ------- Runing the functions ------

    source_pattern = read_EMEBSD(EMEBSDfilename) 

    # Generate reference coordinates
    ref_coords = pattern_coords(Ernould_PC, detector_shape)


    # Determine deformation gradient
    Fe = determineF(e, w)
    h = F2h(Fe, Ernould_PC)

    # Generate deformed pattern
    deformed_pattern = generate_patterns(Fe, Ernould_PC, ref_coords, source_pattern)

    # Visualize the result
    visualize_interpolation(source_pattern, coordtransform(ref_coords, Ernould_PC, Fe), deformed_pattern, PC=Ernould_PC, e=e, w=w, F=Fe, h=h)